
在落地DDD时，关联模型 与软件实现总有让人纠结与苦恼的地方，引起这些苦恼的的主要原因是架构风格的变化。我们已经从多层单体架构时代，过渡到了云原生分布式架构，但所采用的建模思路与编程风格并没有彻底跟上时代的步伐。这种差异通常会以性能问题或是代码坏味道的形式出现。
想要真正发挥出DDD的作用，就需要在不同结构风格下，找到能够维持模型与软件实现统一的办法。

## 关联对象
DDD中的聚合关系在具体实现中会存在一些问题。
### 无法封装的数据库开销
聚合与聚合根是构成"富含知识的模型"的关键。通过聚合关系，可以将北聚合对象的集合逻辑放置在聚合或聚合根，而不是散落在外，或是放在其它无关的服务中，以避免逻辑泄露。
但在落地时，经常会遇到一个挑战，即：这些被聚合的对象，通常都是被数据库持久化的集合。对数据库系统操作无法被接口抽象隔离，而将技术实现引入领域模型，则有悖领域驱动设计的理念。

比如在极客时间的例子里，要对用户已经订阅过的专栏进行分页显示，因为性能原因，不能将DB中的Subscription数据全部读取到内存中再进行分页，而要在查询DB时包含分页逻辑。
那么枫叶落基放在哪里，才能保持模型与软件实现的关联呢？
- 一种做法是为Subscription构造一个独立的Repository对象，将分页逻辑放在里面，但这种做法会导致逻辑泄露。因为Subscription被User聚合，那么User所拥有的Subscription的集合逻辑应该被封装在User中。为非聚合根提供Repository是一种坏味道。
- 那么把分页逻辑放到User上呢，这样其实也不合适，因为这样会将技术实现细节引入领域逻辑中，无法保持领域逻辑的独立。

造成上面两难局面的根源在于：我们希望在模型中使用集合接口，并借助它封装具体实现的细节；这基于一个前提，即内存中的集合与数据库是等价的，都可以通过集合接口封装。但实际情况是，我们无法忽略数据库带来的额外开销，两者并不等价。

### 引入关联对象
关联对象是将对象间的关联关系直接建模出来，然后再通过接口与抽象的隔离，把具体技术实现细节封装到接口的实现中。

User与Subscription间存在关联关系，所以新增一个关联对象来表达：
```
public interface IMySubscriptions : IQueryable<Subscription>
{
  ...
}

public class User
{
  private IMySubscriptions _mySubscriptions;
}
```

这里的关联对象为IMySubscriptions，User是Subscription的聚合根，与之相关的逻辑通过_mySubscriptions完成，仍然在User的上下文中，没有逻辑泄露。
然后，再通过接口与实现分离的方式，从领域对象中移除对具体技术实现的依赖，通过依赖注入的方式提供接口的具体实现：
```
public class MySubscriptionsDB : IMySubscriptions
或者数据来源于Restful API
public class MySubscriptionsAPI : IMySubscriptions
```

`关联对象实际上是通过将隐式的概念显式化建模来解决问题的，这是面向对象技术解决问题的通则：永远可以通过引入另一个对象解决问题。`

## 上下文过载
上下文过载（Context Overloading）就是指领域模型中的某个对象会在多个上下文中发挥重要作用，甚至是聚合根。这会导致对象本身变得很复杂、模型僵化；还可能带来潜在的性能问题。

### 因富含逻辑而产生的过大类
假设之前的极客时间例子中，模型经过扩展后，包含了三个上下文：
1. 订阅：用户阅读订阅内容的上下文，根据订阅关系判断哪些内容是用户可见的；
2. 社交：用户维持朋友关系的上下文，可以分享动态与信息；
3. 订单：用户购买专栏的上下文，通过订单与支付，完成对专栏的订阅。

按照这个模型，得到的富含知识的实现为：
```
public class User
{
  // 社交上下文
  private List<Friendship> _friendships;
  public void Make(Friendship friendship)
  {
  }

  // 订阅上下文
  private List<Subscription> _subscriptions;
  public void Subscribe(Subscription subscription)
  {
  }

  // 订单上下文
  private List<Order> _orders;
  public void PlaceOrder(Order order)
  {
  }
}
```
这个实现的问题在于一个对象包含了不同的上下文，即坏味道：过大类，坏处有
- 模型僵硬，想要理解这个类的行为，就必须理解所有的上下文。只有理解了上下文，才能判断其中的代码和行为是否合理。于是上下文的过载就变成了认知的过载，而认知的过载又会造成维护的困难，出现“看不懂、改不动”的祖传代码。而改不动的代码就是改不动的模型，最终提炼知识的循环也就无法进行了；
- 过大类还容易滋生重复代码、引入偶然耦合造成的意外缺陷；
- 性能问题，在不同的上下文中，需要访问的数据也不尽相同（这个问题可以通过引入关联对象缓解）

### 逻辑汇聚于上下文还是实体
上下文过载的根本症结在于：逻辑汇聚于上下文还是实体。
DDD的默认风格是汇聚于实体，类似这里的User类；而如果根据DCI范型（Data-Context-Interaction，数据-上下文-交互），则应该汇聚于显示建模的上下文对象（Context Object）中，或者上下文中的角色对象（Role Object）中。
这样做的原因是因为，在不同的上下文中，用户是以不同的角色与其他对象发生交互的。User在订阅上下文中的角色是Reader，在订单上下文中是Buyer，在社交上下文中则是Contact。
而发生上下文过载的根源为：实体在不同的上下文中扮演的多个角色，再借由聚合关系，将不同上下文的逻辑富集于实体中，导致了上下文过载。
所以解决方案就是：针对不同上下文的角色建模，将对于的逻辑富集到角色对象中，再让实体对象去扮演不同的角色。

### 通过角色对象分离不同上下文的逻辑
一种实现思路是通过装饰器模式，构造一系列角色对象（Role Object）作为User的装饰器：
```
public class Buyer
{
  private User _user;
  private List<Order> _orders;

  public Buyer(User user)
  {
    _user = user;
  }

  public void PlaceOrder(Order order)
  {
  }
}
public class Reader
{
  private User _user;
  private List<Subscription> _subscriptions;
  
  public Reader(User user)
  {
    _user = user;
  }
  
  public void Subscribe(Subscription subscription)
  {
  }
}
...
```
在具体的Repository实现中使用这些角色对象：
```
public class UserRepositoryDB : IUserRepository
{
  public User FindById(long id)
  {
    return db.ExecuteQuery(...);
  }

  public Buyer AsBuyer(User user)
  {
    return new Buyer(user, db.ExecuteQuery(...));
  }

  public Reader AsReader(User user)
  {
    return new Reader(user, db.ExecuteQuery(...));
  }
}
```
之后，就可以类似下面这样获取角色对象了：
```
var user = repo.FindById(1);
var buyer = repo.AsBuyer(user);
var reader = repo.AsReader(user);
```
使用角色对象的好处：
- 把不同上下文中的逻辑分别富集于不同的角色对象中；解决了认知过载的问题，同时也通过封装隔离了不同上下文的变化。
- 从实体对象转化到角色对象经由了显示的方法调用，这实际上清晰地表示了上下文的切换。

但这个方案在揭示意图、技术解耦上还做得不够好；比如假设不是所有数据都来自数据库，社交上下文中的朋友关系来自Restful API调用，这种情况下，将AsContact放到UserRepositoryDB就不合适了。

### 通过上下文对象分离不同上下文的逻辑
既然将角色转换的逻辑放到UserRepositoryDB不合适，那么借鉴前面关联对象的思路，将上下文直接建模出来，并通过接口隔离具体实现：
```
public interface IOrderContext
{
  interface IBuyer
  {
    void PlaceOrder(Order order);
  }

  IBuyer AsBuyer(User user);
}
public interface ISocialContext
{
  interface IContact
  {
    void Make(Friendship friendship);
  }

  IContact AsContact(User user);
}
public interface ISubscriptionContext
{
  interface IReader
  {
    void Subscribe(Subscription subscription);
  }

  IReader AsReader(User user);
}
```
然后将上下文对象的获取放置到IUserRepository接口中，并在其实现中使用依赖注入获取不同的上下文对象：
```
public interface IUserRepository
{
  User FindUserById(long id);
    
  ISubscriptionContext InSubscriptionContext();
  ISocialContext InSocialContext();
  IOrderContext InOrderContext();
}

public class UserRepositoryDB: IUserRepository
{
  //通过依赖注入获取不同的上下文对象
  private ISubscriptionContext subscriptionContext;
  private ISocialContext socialContext;
  private IOrderContext orderContext;
  ....
}
```
最后的使用方式就成了：
```
var buyer = repo.InOrderContext().AsBuyer(user);
var reader = repo.InSubscriptionContext().AsReader(user);
var contact = repo.InSocialContext().AsContact(user);
```
使用上下文对象重构后得到的好处有：
- 借由上下文的封装，不同上下文中的技术实现可以是异构的，不管数据来自数据库还是第三方API，这些细节都不会暴露给使用者；
- 软件实现、模型、统一语言更加紧密地关联在了一起，上下文对象与界限上下文对应。
- 更加清楚地揭示了领域知识的意图，如下图的领域模型：
![包含上下文的模型](./包含上下文的模型.png)
通过如下IUserRepository的定义可知，User在三个不同的上下文中扮演不同的角色。
```
public interface IUserRepository
{
  User FindUserById(long id);
    
  ISubscriptionContext InSubscriptionContext();
  ISocialContext InSocialContext();
  IOrderContext InOrderContext();
}
```

